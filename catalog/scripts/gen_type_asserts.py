import typing as t
import re
from pathlib import Path
from textwrap import dedent

# Fields that are pointers in the model but referenced without dereferencing in assertions
# Format: (field_name, assertion_func_name)
POINTER_FIELD_FIXES = [
    # McpServer fields that are pointers
    ('obj.SecurityIndicators', 'AssertMcpSecurityIndicatorConstraints'),
    ('obj.SecurityIndicators', 'AssertMcpSecurityIndicatorRequired'),
    ('obj.Endpoints', 'AssertMcpEndpointsConstraints'),
    ('obj.Endpoints', 'AssertMcpEndpointsRequired'),
]

def fix_pointer_dereferences(func: str) -> str:
    """Fix pointer dereference issues in assertion functions.

    When a field is a pointer type but passed to a function expecting a non-pointer,
    we need to wrap it with nil check and dereference.
    """
    result = func

    for field_name, func_name in POINTER_FIELD_FIXES:
        # Find patterns like:
        # \tif err := AssertMcpSecurityIndicatorConstraints(obj.SecurityIndicators); err != nil {
        # \t\treturn err
        # \t}
        old_pattern = f'\tif err := {func_name}({field_name}); err != nil {{\n\t\treturn err\n\t}}'
        new_pattern = f'\tif {field_name} != nil {{\n\t\tif err := {func_name}(*{field_name}); err != nil {{\n\t\t\treturn err\n\t\t}}\n\t}}'

        result = result.replace(old_pattern, new_pattern)

    return result

def get_funcs(models: t.Iterable[Path]) -> t.Iterator[str]:
    for path in models:
        with path.open() as f:
            # skip boilerplate
            lines = iter(f.readlines())
            while not next(lines).startswith("package"):
                continue

            buf = []
            in_func = False
            in_import = False
            for raw in lines:
                line = raw.rstrip()
                if not line and not in_func:
                    continue

                if line.startswith("import "):
                    in_import = True
                    continue
                elif line == ")" and in_import:
                    in_import = False
                    buf.clear()
                    continue

                buf.append(line)
                if line.startswith("func"):
                    in_func = True
                elif line.startswith("}") and in_func:
                    in_func = False
                    func_str = "\n".join(buf)
                    # Apply pointer dereference fixes
                    func_str = fix_pointer_dereferences(func_str)
                    yield func_str
                    buf.clear()
        path.unlink()


def get_name(func: str) -> str:
    # each func is declared as:
    # // comment
    # func funcName(args) error ...
    return func.split("\n")[1].split(" ")[1].split("(")[0]


if __name__ == "__main__":
    # model catalog package root
    root = Path(__file__).parent.parent.resolve()
    src = root / "internal/server/openapi"

    print(
        dedent("""
/*
 * Model Registry REST API
 *
 * REST API for Model Registry to create and manage ML model metadata
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 *
 */

// File generated by scripts/gen_type_assert.sh - DO NOT EDIT

package openapi

import (
    model "github.com/kubeflow/model-registry/catalog/pkg/openapi"
)

    """)
    )
    print(
        "\n".join(
            sorted(
                get_funcs(path for path in src.rglob("model_*.go")),
                key=lambda f: get_name(f),
            )
        )
    )
