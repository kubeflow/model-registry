
"""Model Catalog REST API

REST API for Model Registry to create and manage ML model metadata

The version of the OpenAPI document: v1alpha1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing_extensions import Self

from catalog_openapi.models.catalog_source_status import CatalogSourceStatus


class CatalogSource(BaseModel):
    """A catalog source. A catalog source has CatalogModel children.
    """ # noqa: E501
    id: StrictStr = Field(description="A unique identifier for a `CatalogSource`.")
    name: StrictStr = Field(description="The name of the catalog source.")
    enabled: StrictBool | None = Field(default=True, description="Whether the catalog source is enabled.")
    labels: list[StrictStr] = Field(description="Labels for the catalog source.")
    status: CatalogSourceStatus | None = None
    error: StrictStr | None = Field(default=None, description='Detailed error information when the status is "Error". This field is null or empty when the source is functioning normally.')
    included_models: list[StrictStr] | None = Field(default=None, description='Optional list of glob patterns for models to include. If specified, only models matching at least one pattern will be included. If omitted, all models are considered for inclusion.  Pattern Syntax: - Only the `*` wildcard is supported (matches zero or more characters) - Patterns are case-insensitive (e.g., `Granite/*` matches `granite/model` and `GRANITE/model`) - Patterns match the entire model name (anchored at start and end) - Wildcards can appear anywhere: `Granite/*`, `*-beta`, `*deprecated*`, `*/old*`  Examples: - `ibm-granite/*` - matches all models starting with "ibm-granite/" - `meta-llama/*` - matches all models in the meta-llama namespace - `*` - matches all models  Constraints: - Patterns cannot be empty or whitespace-only - A pattern cannot appear in both includedModels and excludedModels', alias="includedModels")
    excluded_models: list[StrictStr] | None = Field(default=None, description='Optional list of glob patterns for models to exclude. Models matching any pattern will be excluded even if they match an includedModels pattern. Exclusions take precedence over inclusions.  Pattern Syntax: - Only the `*` wildcard is supported (matches zero or more characters) - Patterns are case-insensitive - Patterns match the entire model name (anchored at start and end) - Wildcards can appear anywhere in the pattern  Examples: - `*-draft` - excludes all models ending with "-draft" - `*-experimental` - excludes experimental models - `*deprecated*` - excludes models with "deprecated" anywhere in the name - `*/beta-*` - excludes models with "/beta-" in the path  Constraints: - Patterns cannot be empty or whitespace-only - A pattern cannot appear in both includedModels and excludedModels', alias="excludedModels")
    __properties: ClassVar[list[str]] = ["id", "name", "enabled", "labels", "status", "error", "includedModels", "excludedModels"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self | None:
        """Create an instance of CatalogSource from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if error (nullable) is None
        # and model_fields_set contains the field
        if self.error is None and "error" in self.model_fields_set:
            _dict["error"] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict[str, Any] | None) -> Self | None:
        """Create an instance of CatalogSource from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "name": obj.get("name"),
            "enabled": obj.get("enabled") if obj.get("enabled") is not None else True,
            "labels": obj.get("labels"),
            "status": obj.get("status"),
            "error": obj.get("error"),
            "includedModels": obj.get("includedModels"),
            "excludedModels": obj.get("excludedModels")
        })
        return _obj


