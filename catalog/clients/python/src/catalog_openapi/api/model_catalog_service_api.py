
"""Model Catalog REST API

REST API for Model Registry to create and manage ML model metadata

The version of the OpenAPI document: v1alpha1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Annotated, Any

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, validate_call

from catalog_openapi.api_client import ApiClient, RequestSerialized
from catalog_openapi.api_response import ApiResponse
from catalog_openapi.models.artifact_type_query_param import ArtifactTypeQueryParam
from catalog_openapi.models.catalog_artifact_list import CatalogArtifactList
from catalog_openapi.models.catalog_label_list import CatalogLabelList
from catalog_openapi.models.catalog_model import CatalogModel
from catalog_openapi.models.catalog_model_list import CatalogModelList
from catalog_openapi.models.catalog_source_list import CatalogSourceList
from catalog_openapi.models.catalog_source_preview_response import CatalogSourcePreviewResponse
from catalog_openapi.models.filter_options_list import FilterOptionsList
from catalog_openapi.models.order_by_field import OrderByField
from catalog_openapi.models.sort_order import SortOrder
from catalog_openapi.rest import RESTResponseType


class ModelCatalogServiceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def find_labels(
        self,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the key to order catalog labels by. You can provide any string key that may exist in the label maps. Labels that contain the specified key will be sorted by that key's value. Labels that don't contain the key will maintain their original order and appear after labels that do contain the key. ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogLabelList:
        """List All CatalogLabels

        Gets a list of all `CatalogLabel` entities.

        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the key to order catalog labels by. You can provide any string key that may exist in the label maps. Labels that contain the specified key will be sorted by that key's value. Labels that don't contain the key will maintain their original order and appear after labels that do contain the key. 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_labels_serialize(
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogLabelList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_labels_with_http_info(
        self,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the key to order catalog labels by. You can provide any string key that may exist in the label maps. Labels that contain the specified key will be sorted by that key's value. Labels that don't contain the key will maintain their original order and appear after labels that do contain the key. ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogLabelList]:
        """List All CatalogLabels

        Gets a list of all `CatalogLabel` entities.

        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the key to order catalog labels by. You can provide any string key that may exist in the label maps. Labels that contain the specified key will be sorted by that key's value. Labels that don't contain the key will maintain their original order and appear after labels that do contain the key. 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_labels_serialize(
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogLabelList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_labels_without_preload_content(
        self,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the key to order catalog labels by. You can provide any string key that may exist in the label maps. Labels that contain the specified key will be sorted by that key's value. Labels that don't contain the key will maintain their original order and appear after labels that do contain the key. ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List All CatalogLabels

        Gets a list of all `CatalogLabel` entities.

        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the key to order catalog labels by. You can provide any string key that may exist in the label maps. Labels that contain the specified key will be sorted by that key's value. Labels that don't contain the key will maintain their original order and appear after labels that do contain the key. 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_labels_serialize(
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogLabelList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_labels_serialize(
        self,
        page_size,
        order_by,
        sort_order,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if order_by is not None:

            _query_params.append(("orderBy", order_by))

        if sort_order is not None:

            _query_params.append(("sortOrder", sort_order.value))

        if next_page_token is not None:

            _query_params.append(("nextPageToken", next_page_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/labels",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_models(
        self,
        source: Annotated[list[StrictStr] | None, Field(description="Filter models by source. Multiple values can be separated by commas to filter by multiple sources (OR logic). For example: ?source=huggingface,local will return models from either huggingface OR local sources.")] = None,
        q: Annotated[StrictStr | None, Field(description="Free-form keyword search used to filter the response.")] = None,
        source_label: Annotated[list[StrictStr] | None, Field(description="Filter models by the label associated with the source. Multiple values can be separated by commas. If one of the values is the string `null`, then models from every source without a label will be returned.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter the list of entities. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access:** - Standard properties: `name`, `id`, `state`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-model\"` - Comparison: `accuracy > 0.95` - Pattern: `name LIKE \"%tensorflow%\"` - Complex: `(name = \"model-a\" OR name = \"model-b\") AND state = \"LIVE\"` - Custom property: `framework.string_value = \"pytorch\"` - Escaped property: `` `mlflow.source.type` = \"notebook\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[OrderByField | None, Field(description="Specifies the order by criteria for listing entities.  Supported values are: - CREATE_TIME - LAST_UPDATE_TIME - ID - NAME - ACCURACY  The `ACCURACY` sort will sort by the `overall_average` property in any linked metrics artifact.  In addition, models can be sorted by properties. For example: - `provider.string_value` sorts by provider name - `artifacts.ifeval.double_value` sorts by the min/max value a property called ifeval across all associated artifacts")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogModelList:
        """Search catalog models across sources.

        :param source: Filter models by source. Multiple values can be separated by commas to filter by multiple sources (OR logic). For example: ?source=huggingface,local will return models from either huggingface OR local sources.
        :type source: List[str]
        :param q: Free-form keyword search used to filter the response.
        :type q: str
        :param source_label: Filter models by the label associated with the source. Multiple values can be separated by commas. If one of the values is the string `null`, then models from every source without a label will be returned.
        :type source_label: List[str]
        :param filter_query: A SQL-like query string to filter the list of entities. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access:** - Standard properties: `name`, `id`, `state`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-model\"` - Comparison: `accuracy > 0.95` - Pattern: `name LIKE \"%tensorflow%\"` - Complex: `(name = \"model-a\" OR name = \"model-b\") AND state = \"LIVE\"` - Custom property: `framework.string_value = \"pytorch\"` - Escaped property: `` `mlflow.source.type` = \"notebook\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing entities.  Supported values are: - CREATE_TIME - LAST_UPDATE_TIME - ID - NAME - ACCURACY  The `ACCURACY` sort will sort by the `overall_average` property in any linked metrics artifact.  In addition, models can be sorted by properties. For example: - `provider.string_value` sorts by provider name - `artifacts.ifeval.double_value` sorts by the min/max value a property called ifeval across all associated artifacts
        :type order_by: OrderByField
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_models_serialize(
            source=source,
            q=q,
            source_label=source_label,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogModelList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_models_with_http_info(
        self,
        source: Annotated[list[StrictStr] | None, Field(description="Filter models by source. Multiple values can be separated by commas to filter by multiple sources (OR logic). For example: ?source=huggingface,local will return models from either huggingface OR local sources.")] = None,
        q: Annotated[StrictStr | None, Field(description="Free-form keyword search used to filter the response.")] = None,
        source_label: Annotated[list[StrictStr] | None, Field(description="Filter models by the label associated with the source. Multiple values can be separated by commas. If one of the values is the string `null`, then models from every source without a label will be returned.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter the list of entities. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access:** - Standard properties: `name`, `id`, `state`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-model\"` - Comparison: `accuracy > 0.95` - Pattern: `name LIKE \"%tensorflow%\"` - Complex: `(name = \"model-a\" OR name = \"model-b\") AND state = \"LIVE\"` - Custom property: `framework.string_value = \"pytorch\"` - Escaped property: `` `mlflow.source.type` = \"notebook\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[OrderByField | None, Field(description="Specifies the order by criteria for listing entities.  Supported values are: - CREATE_TIME - LAST_UPDATE_TIME - ID - NAME - ACCURACY  The `ACCURACY` sort will sort by the `overall_average` property in any linked metrics artifact.  In addition, models can be sorted by properties. For example: - `provider.string_value` sorts by provider name - `artifacts.ifeval.double_value` sorts by the min/max value a property called ifeval across all associated artifacts")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogModelList]:
        """Search catalog models across sources.

        :param source: Filter models by source. Multiple values can be separated by commas to filter by multiple sources (OR logic). For example: ?source=huggingface,local will return models from either huggingface OR local sources.
        :type source: List[str]
        :param q: Free-form keyword search used to filter the response.
        :type q: str
        :param source_label: Filter models by the label associated with the source. Multiple values can be separated by commas. If one of the values is the string `null`, then models from every source without a label will be returned.
        :type source_label: List[str]
        :param filter_query: A SQL-like query string to filter the list of entities. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access:** - Standard properties: `name`, `id`, `state`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-model\"` - Comparison: `accuracy > 0.95` - Pattern: `name LIKE \"%tensorflow%\"` - Complex: `(name = \"model-a\" OR name = \"model-b\") AND state = \"LIVE\"` - Custom property: `framework.string_value = \"pytorch\"` - Escaped property: `` `mlflow.source.type` = \"notebook\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing entities.  Supported values are: - CREATE_TIME - LAST_UPDATE_TIME - ID - NAME - ACCURACY  The `ACCURACY` sort will sort by the `overall_average` property in any linked metrics artifact.  In addition, models can be sorted by properties. For example: - `provider.string_value` sorts by provider name - `artifacts.ifeval.double_value` sorts by the min/max value a property called ifeval across all associated artifacts
        :type order_by: OrderByField
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_models_serialize(
            source=source,
            q=q,
            source_label=source_label,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogModelList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_models_without_preload_content(
        self,
        source: Annotated[list[StrictStr] | None, Field(description="Filter models by source. Multiple values can be separated by commas to filter by multiple sources (OR logic). For example: ?source=huggingface,local will return models from either huggingface OR local sources.")] = None,
        q: Annotated[StrictStr | None, Field(description="Free-form keyword search used to filter the response.")] = None,
        source_label: Annotated[list[StrictStr] | None, Field(description="Filter models by the label associated with the source. Multiple values can be separated by commas. If one of the values is the string `null`, then models from every source without a label will be returned.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter the list of entities. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access:** - Standard properties: `name`, `id`, `state`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-model\"` - Comparison: `accuracy > 0.95` - Pattern: `name LIKE \"%tensorflow%\"` - Complex: `(name = \"model-a\" OR name = \"model-b\") AND state = \"LIVE\"` - Custom property: `framework.string_value = \"pytorch\"` - Escaped property: `` `mlflow.source.type` = \"notebook\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[OrderByField | None, Field(description="Specifies the order by criteria for listing entities.  Supported values are: - CREATE_TIME - LAST_UPDATE_TIME - ID - NAME - ACCURACY  The `ACCURACY` sort will sort by the `overall_average` property in any linked metrics artifact.  In addition, models can be sorted by properties. For example: - `provider.string_value` sorts by provider name - `artifacts.ifeval.double_value` sorts by the min/max value a property called ifeval across all associated artifacts")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search catalog models across sources.

        :param source: Filter models by source. Multiple values can be separated by commas to filter by multiple sources (OR logic). For example: ?source=huggingface,local will return models from either huggingface OR local sources.
        :type source: List[str]
        :param q: Free-form keyword search used to filter the response.
        :type q: str
        :param source_label: Filter models by the label associated with the source. Multiple values can be separated by commas. If one of the values is the string `null`, then models from every source without a label will be returned.
        :type source_label: List[str]
        :param filter_query: A SQL-like query string to filter the list of entities. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access:** - Standard properties: `name`, `id`, `state`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-model\"` - Comparison: `accuracy > 0.95` - Pattern: `name LIKE \"%tensorflow%\"` - Complex: `(name = \"model-a\" OR name = \"model-b\") AND state = \"LIVE\"` - Custom property: `framework.string_value = \"pytorch\"` - Escaped property: `` `mlflow.source.type` = \"notebook\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing entities.  Supported values are: - CREATE_TIME - LAST_UPDATE_TIME - ID - NAME - ACCURACY  The `ACCURACY` sort will sort by the `overall_average` property in any linked metrics artifact.  In addition, models can be sorted by properties. For example: - `provider.string_value` sorts by provider name - `artifacts.ifeval.double_value` sorts by the min/max value a property called ifeval across all associated artifacts
        :type order_by: OrderByField
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_models_serialize(
            source=source,
            q=q,
            source_label=source_label,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogModelList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_models_serialize(
        self,
        source,
        q,
        source_label,
        filter_query,
        page_size,
        order_by,
        sort_order,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "source": "multi",
            "sourceLabel": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if source is not None:

            _query_params.append(("source", source))

        if q is not None:

            _query_params.append(("q", q))

        if source_label is not None:

            _query_params.append(("sourceLabel", source_label))

        if filter_query is not None:

            _query_params.append(("filterQuery", filter_query))

        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if order_by is not None:

            _query_params.append(("orderBy", order_by.value))

        if sort_order is not None:

            _query_params.append(("sortOrder", sort_order.value))

        if next_page_token is not None:

            _query_params.append(("nextPageToken", next_page_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/models",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_models_filter_options(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilterOptionsList:
        """Lists fields and available options that can be used in `filterQuery` on the list models endpoint.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_models_filter_options_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "FilterOptionsList",
            "400": "Error",
            "401": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_models_filter_options_with_http_info(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilterOptionsList]:
        """Lists fields and available options that can be used in `filterQuery` on the list models endpoint.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_models_filter_options_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "FilterOptionsList",
            "400": "Error",
            "401": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_models_filter_options_without_preload_content(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lists fields and available options that can be used in `filterQuery` on the list models endpoint.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_models_filter_options_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "FilterOptionsList",
            "400": "Error",
            "401": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_models_filter_options_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/models/filter_options",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def find_sources(
        self,
        name: Annotated[StrictStr | None, Field(description="Name of entity to search.")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[OrderByField | None, Field(description="Specifies the order by criteria for listing entities.")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogSourceList:
        """List All CatalogSources

        Gets a list of all `CatalogSource` entities.

        :param name: Name of entity to search.
        :type name: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing entities.
        :type order_by: OrderByField
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_sources_serialize(
            name=name,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogSourceList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def find_sources_with_http_info(
        self,
        name: Annotated[StrictStr | None, Field(description="Name of entity to search.")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[OrderByField | None, Field(description="Specifies the order by criteria for listing entities.")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogSourceList]:
        """List All CatalogSources

        Gets a list of all `CatalogSource` entities.

        :param name: Name of entity to search.
        :type name: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing entities.
        :type order_by: OrderByField
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_sources_serialize(
            name=name,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogSourceList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def find_sources_without_preload_content(
        self,
        name: Annotated[StrictStr | None, Field(description="Name of entity to search.")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[OrderByField | None, Field(description="Specifies the order by criteria for listing entities.")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List All CatalogSources

        Gets a list of all `CatalogSource` entities.

        :param name: Name of entity to search.
        :type name: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing entities.
        :type order_by: OrderByField
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._find_sources_serialize(
            name=name,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogSourceList",
            "400": "Error",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _find_sources_serialize(
        self,
        name,
        page_size,
        order_by,
        sort_order,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if name is not None:

            _query_params.append(("name", name))

        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if order_by is not None:

            _query_params.append(("orderBy", order_by.value))

        if sort_order is not None:

            _query_params.append(("sortOrder", sort_order.value))

        if next_page_token is not None:

            _query_params.append(("nextPageToken", next_page_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/sources",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_model_artifacts(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        artifact_type: Annotated[list[ArtifactTypeQueryParam] | None, Field(description="Specifies the artifact type for listing artifacts.")] = None,
        artifact_type2: Annotated[list[ArtifactTypeQueryParam] | None, Field(description="Specifies the artifact type for listing artifacts.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogArtifactList:
        """List CatalogArtifacts.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param artifact_type: Specifies the artifact type for listing artifacts.
        :type artifact_type: List[ArtifactTypeQueryParam]
        :param artifact_type2: Specifies the artifact type for listing artifacts.
        :type artifact_type2: List[ArtifactTypeQueryParam]
        :param filter_query: A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_all_model_artifacts_serialize(
            source_id=source_id,
            model_name=model_name,
            artifact_type=artifact_type,
            artifact_type2=artifact_type2,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogArtifactList",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_model_artifacts_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        artifact_type: Annotated[list[ArtifactTypeQueryParam] | None, Field(description="Specifies the artifact type for listing artifacts.")] = None,
        artifact_type2: Annotated[list[ArtifactTypeQueryParam] | None, Field(description="Specifies the artifact type for listing artifacts.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogArtifactList]:
        """List CatalogArtifacts.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param artifact_type: Specifies the artifact type for listing artifacts.
        :type artifact_type: List[ArtifactTypeQueryParam]
        :param artifact_type2: Specifies the artifact type for listing artifacts.
        :type artifact_type2: List[ArtifactTypeQueryParam]
        :param filter_query: A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_all_model_artifacts_serialize(
            source_id=source_id,
            model_name=model_name,
            artifact_type=artifact_type,
            artifact_type2=artifact_type2,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogArtifactList",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_model_artifacts_without_preload_content(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        artifact_type: Annotated[list[ArtifactTypeQueryParam] | None, Field(description="Specifies the artifact type for listing artifacts.")] = None,
        artifact_type2: Annotated[list[ArtifactTypeQueryParam] | None, Field(description="Specifies the artifact type for listing artifacts.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List CatalogArtifacts.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param artifact_type: Specifies the artifact type for listing artifacts.
        :type artifact_type: List[ArtifactTypeQueryParam]
        :param artifact_type2: Specifies the artifact type for listing artifacts.
        :type artifact_type2: List[ArtifactTypeQueryParam]
        :param filter_query: A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_all_model_artifacts_serialize(
            source_id=source_id,
            model_name=model_name,
            artifact_type=artifact_type,
            artifact_type2=artifact_type2,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogArtifactList",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_model_artifacts_serialize(
        self,
        source_id,
        model_name,
        artifact_type,
        artifact_type2,
        filter_query,
        page_size,
        order_by,
        sort_order,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "artifactType": "multi",
            "artifact_type": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if source_id is not None:
            _path_params["source_id"] = source_id
        if model_name is not None:
            _path_params["model_name"] = model_name
        # process the query parameters
        if artifact_type is not None:

            _query_params.append(("artifactType", artifact_type))

        if artifact_type2 is not None:

            _query_params.append(("artifact_type", artifact_type2))

        if filter_query is not None:

            _query_params.append(("filterQuery", filter_query))

        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if order_by is not None:

            _query_params.append(("orderBy", order_by))

        if sort_order is not None:

            _query_params.append(("sortOrder", sort_order.value))

        if next_page_token is not None:

            _query_params.append(("nextPageToken", next_page_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/sources/{source_id}/models/{model_name}/artifacts",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_model_performance_artifacts(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        target_rps: Annotated[StrictInt | None, Field(description="Target requests per second. If specified, values for `replicas` and `total_requests_per_second` will be calculated and returned as custom properties.")] = None,
        recommendations: Annotated[StrictBool | None, Field(description="Filter records that are less optimal based on approximate cost to run and latency.")] = None,
        rps_property: Annotated[StrictStr | None, Field(description="Custom property name for requests per second metric.")] = None,
        latency_property: Annotated[StrictStr | None, Field(description="Custom property name for latency metric (e.g., ttft_p90, p90_latency).")] = None,
        hardware_count_property: Annotated[StrictStr | None, Field(description="Custom property name for hardware count metric.")] = None,
        hardware_type_property: Annotated[StrictStr | None, Field(description="Custom property name for hardware type grouping.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogArtifactList:
        """List CatalogArtifacts.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param target_rps: Target requests per second. If specified, values for `replicas` and `total_requests_per_second` will be calculated and returned as custom properties.
        :type target_rps: int
        :param recommendations: Filter records that are less optimal based on approximate cost to run and latency.
        :type recommendations: bool
        :param rps_property: Custom property name for requests per second metric.
        :type rps_property: str
        :param latency_property: Custom property name for latency metric (e.g., ttft_p90, p90_latency).
        :type latency_property: str
        :param hardware_count_property: Custom property name for hardware count metric.
        :type hardware_count_property: str
        :param hardware_type_property: Custom property name for hardware type grouping.
        :type hardware_type_property: str
        :param filter_query: A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_all_model_performance_artifacts_serialize(
            source_id=source_id,
            model_name=model_name,
            target_rps=target_rps,
            recommendations=recommendations,
            rps_property=rps_property,
            latency_property=latency_property,
            hardware_count_property=hardware_count_property,
            hardware_type_property=hardware_type_property,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogArtifactList",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_model_performance_artifacts_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        target_rps: Annotated[StrictInt | None, Field(description="Target requests per second. If specified, values for `replicas` and `total_requests_per_second` will be calculated and returned as custom properties.")] = None,
        recommendations: Annotated[StrictBool | None, Field(description="Filter records that are less optimal based on approximate cost to run and latency.")] = None,
        rps_property: Annotated[StrictStr | None, Field(description="Custom property name for requests per second metric.")] = None,
        latency_property: Annotated[StrictStr | None, Field(description="Custom property name for latency metric (e.g., ttft_p90, p90_latency).")] = None,
        hardware_count_property: Annotated[StrictStr | None, Field(description="Custom property name for hardware count metric.")] = None,
        hardware_type_property: Annotated[StrictStr | None, Field(description="Custom property name for hardware type grouping.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogArtifactList]:
        """List CatalogArtifacts.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param target_rps: Target requests per second. If specified, values for `replicas` and `total_requests_per_second` will be calculated and returned as custom properties.
        :type target_rps: int
        :param recommendations: Filter records that are less optimal based on approximate cost to run and latency.
        :type recommendations: bool
        :param rps_property: Custom property name for requests per second metric.
        :type rps_property: str
        :param latency_property: Custom property name for latency metric (e.g., ttft_p90, p90_latency).
        :type latency_property: str
        :param hardware_count_property: Custom property name for hardware count metric.
        :type hardware_count_property: str
        :param hardware_type_property: Custom property name for hardware type grouping.
        :type hardware_type_property: str
        :param filter_query: A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_all_model_performance_artifacts_serialize(
            source_id=source_id,
            model_name=model_name,
            target_rps=target_rps,
            recommendations=recommendations,
            rps_property=rps_property,
            latency_property=latency_property,
            hardware_count_property=hardware_count_property,
            hardware_type_property=hardware_type_property,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogArtifactList",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_model_performance_artifacts_without_preload_content(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        target_rps: Annotated[StrictInt | None, Field(description="Target requests per second. If specified, values for `replicas` and `total_requests_per_second` will be calculated and returned as custom properties.")] = None,
        recommendations: Annotated[StrictBool | None, Field(description="Filter records that are less optimal based on approximate cost to run and latency.")] = None,
        rps_property: Annotated[StrictStr | None, Field(description="Custom property name for requests per second metric.")] = None,
        latency_property: Annotated[StrictStr | None, Field(description="Custom property name for latency metric (e.g., ttft_p90, p90_latency).")] = None,
        hardware_count_property: Annotated[StrictStr | None, Field(description="Custom property name for hardware count metric.")] = None,
        hardware_type_property: Annotated[StrictStr | None, Field(description="Custom property name for hardware type grouping.")] = None,
        filter_query: Annotated[StrictStr | None, Field(description="A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` ")] = None,
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        order_by: Annotated[StrictStr | None, Field(description="Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error ")] = None,
        sort_order: Annotated[SortOrder | None, Field(description="Specifies the sort order for listing entities, defaults to ASC.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List CatalogArtifacts.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param target_rps: Target requests per second. If specified, values for `replicas` and `total_requests_per_second` will be calculated and returned as custom properties.
        :type target_rps: int
        :param recommendations: Filter records that are less optimal based on approximate cost to run and latency.
        :type recommendations: bool
        :param rps_property: Custom property name for requests per second metric.
        :type rps_property: str
        :param latency_property: Custom property name for latency metric (e.g., ttft_p90, p90_latency).
        :type latency_property: str
        :param hardware_count_property: Custom property name for hardware count metric.
        :type hardware_count_property: str
        :param hardware_type_property: Custom property name for hardware type grouping.
        :type hardware_type_property: str
        :param filter_query: A SQL-like query string to filter catalog artifacts. The query supports rich filtering capabilities with automatic type inference.  **Supported Operators:** - Comparison: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=` - Pattern matching: `LIKE`, `ILIKE` (case-insensitive) - Set membership: `IN` - Logical: `AND`, `OR` - Grouping: `()` for complex expressions  **Data Types:** - Strings: `\"value\"` or `'value'` - Numbers: `42`, `3.14`, `1e-5` - Booleans: `true`, `false` (case-insensitive)  **Property Access (Artifacts):** - Standard properties: `name`, `id`, `uri`, `artifactType`, `createTimeSinceEpoch` - Custom properties: Any user-defined property name in `customProperties` - Escaped properties: Use backticks for special characters: `` `custom-property` `` - Type-specific access: `property.string_value`, `property.double_value`, `property.int_value`, `property.bool_value`  **Examples:** - Basic: `name = \"my-artifact\"` - Comparison: `ttft_mean > 90` - Pattern: `uri LIKE \"%s3.amazonaws.com%\"` - Complex: `(artifactType = \"model-artifact\" OR artifactType = \"metrics-artifact\") AND name LIKE \"%pytorch%\"` - Custom property: `format.string_value = \"pytorch\"` - Escaped property: `` `custom-key` = \"value\" `` 
        :type filter_query: str
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param order_by: Specifies the order by criteria for listing artifacts.  **Standard Fields:** - `ID` - Order by artifact ID - `NAME` - Order by artifact name - `CREATE_TIME` - Order by creation timestamp - `LAST_UPDATE_TIME` - Order by last update timestamp  **Custom Property Ordering:**  Artifacts can be ordered by custom properties using the format: `<property_name>.<value_type>`  Supported value types: - `double_value` - For numeric (floating-point) properties - `int_value` - For integer properties - `string_value` - For string properties  Examples: - `mmlu.double_value` - Order by the 'mmlu' benchmark score - `accuracy.double_value` - Order by accuracy metric - `framework_type.string_value` - Order by framework type - `hardware_count.int_value` - Order by hardware count - `ttft_mean.double_value` - Order by time-to-first-token mean  **Behavior:** - If an invalid value type is specified (e.g., `accuracy.invalid_type`), an error is returned - If an invalid format is used (e.g., `accuracy` without `.value_type`), it falls back to ID ordering - If a property doesn't exist, it falls back to ID ordering - Artifacts with the specified property are ordered first (by the property value), followed by artifacts without the property (ordered by ID) - Empty property names (e.g., `.double_value`) return an error 
        :type order_by: str
        :param sort_order: Specifies the sort order for listing entities, defaults to ASC.
        :type sort_order: SortOrder
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_all_model_performance_artifacts_serialize(
            source_id=source_id,
            model_name=model_name,
            target_rps=target_rps,
            recommendations=recommendations,
            rps_property=rps_property,
            latency_property=latency_property,
            hardware_count_property=hardware_count_property,
            hardware_type_property=hardware_type_property,
            filter_query=filter_query,
            page_size=page_size,
            order_by=order_by,
            sort_order=sort_order,
            next_page_token=next_page_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogArtifactList",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_model_performance_artifacts_serialize(
        self,
        source_id,
        model_name,
        target_rps,
        recommendations,
        rps_property,
        latency_property,
        hardware_count_property,
        hardware_type_property,
        filter_query,
        page_size,
        order_by,
        sort_order,
        next_page_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if source_id is not None:
            _path_params["source_id"] = source_id
        if model_name is not None:
            _path_params["model_name"] = model_name
        # process the query parameters
        if target_rps is not None:

            _query_params.append(("targetRPS", target_rps))

        if recommendations is not None:

            _query_params.append(("recommendations", recommendations))

        if rps_property is not None:

            _query_params.append(("rpsProperty", rps_property))

        if latency_property is not None:

            _query_params.append(("latencyProperty", latency_property))

        if hardware_count_property is not None:

            _query_params.append(("hardwareCountProperty", hardware_count_property))

        if hardware_type_property is not None:

            _query_params.append(("hardwareTypeProperty", hardware_type_property))

        if filter_query is not None:

            _query_params.append(("filterQuery", filter_query))

        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if order_by is not None:

            _query_params.append(("orderBy", order_by))

        if sort_order is not None:

            _query_params.append(("sortOrder", sort_order.value))

        if next_page_token is not None:

            _query_params.append(("nextPageToken", next_page_token))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/sources/{source_id}/models/{model_name}/artifacts/performance",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_model(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogModel:
        """Get a `CatalogModel`.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_model_serialize(
            source_id=source_id,
            model_name=model_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogModel",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_model_with_http_info(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogModel]:
        """Get a `CatalogModel`.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_model_serialize(
            source_id=source_id,
            model_name=model_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogModel",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_model_without_preload_content(
        self,
        source_id: Annotated[StrictStr, Field(description="A unique identifier for a `CatalogSource`.")],
        model_name: Annotated[StrictStr, Field(description="A unique identifier for the model.")],
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a `CatalogModel`.

        :param source_id: A unique identifier for a `CatalogSource`. (required)
        :type source_id: str
        :param model_name: A unique identifier for the model. (required)
        :type model_name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._get_model_serialize(
            source_id=source_id,
            model_name=model_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogModel",
            "401": "Error",
            "404": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_model_serialize(
        self,
        source_id,
        model_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if source_id is not None:
            _path_params["source_id"] = source_id
        if model_name is not None:
            _path_params["model_name+"] = model_name
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/model_catalog/v1alpha1/sources/{source_id}/models/{model_name+}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def preview_catalog_source(
        self,
        config: Annotated[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes], Field(description='YAML file containing the catalog source configuration. The file should contain a source definition with type and properties fields, including optional includedModels and excludedModels filters.  Model filter patterns support the `*` wildcard only and are case-insensitive. Patterns match the entire model name (e.g., `ibm-granite/*` matches all models starting with \\"ibm-granite/\\").')],
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        filter_status: Annotated[StrictStr | None, Field(description="Filter the response to show specific model statuses: - `all` (default): Show all models regardless of inclusion status - `included`: Show only models that pass the configured filters - `excluded`: Show only models that are filtered out")] = None,
        catalog_data: Annotated[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes] | None, Field(description="Optional YAML file containing the catalog data (models).  This field enables stateless preview of new sources before saving them. When provided, the catalog data is read directly from this file instead of from the `yamlCatalogPath` property in the config.  **Two modes of operation:** 1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files. The models are read from `catalogData`, allowing preview    without saving anything to the server. 2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property pointing to a catalog file on the server filesystem.  If both `catalogData` and `yamlCatalogPath` are provided, `catalogData` takes precedence.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CatalogSourcePreviewResponse:
        """Preview catalog source configuration

        Accepts a catalog source configuration and returns a list of models showing which would be included or excluded based on the configured filters. This allows users to test and validate their source configurations before applying them.  **Two modes of operation:**  1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files via multipart form. The models are read directly from    the uploaded `catalogData`, enabling preview of new sources before saving    anything to the server. This is ideal for testing configurations.  2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property. The models are read from the specified file path on the server.    Use this for previewing changes to existing saved sources.

        :param config: YAML file containing the catalog source configuration. The file should contain a source definition with type and properties fields, including optional includedModels and excludedModels filters.  Model filter patterns support the `*` wildcard only and are case-insensitive. Patterns match the entire model name (e.g., `ibm-granite/*` matches all models starting with \\\"ibm-granite/\\\"). (required)
        :type config: bytearray
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param filter_status: Filter the response to show specific model statuses: - `all` (default): Show all models regardless of inclusion status - `included`: Show only models that pass the configured filters - `excluded`: Show only models that are filtered out
        :type filter_status: str
        :param catalog_data: Optional YAML file containing the catalog data (models).  This field enables stateless preview of new sources before saving them. When provided, the catalog data is read directly from this file instead of from the `yamlCatalogPath` property in the config.  **Two modes of operation:** 1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files. The models are read from `catalogData`, allowing preview    without saving anything to the server. 2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property pointing to a catalog file on the server filesystem.  If both `catalogData` and `yamlCatalogPath` are provided, `catalogData` takes precedence.
        :type catalog_data: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._preview_catalog_source_serialize(
            config=config,
            page_size=page_size,
            next_page_token=next_page_token,
            filter_status=filter_status,
            catalog_data=catalog_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogSourcePreviewResponse",
            "400": "Error",
            "401": "Error",
            "422": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def preview_catalog_source_with_http_info(
        self,
        config: Annotated[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes], Field(description='YAML file containing the catalog source configuration. The file should contain a source definition with type and properties fields, including optional includedModels and excludedModels filters.  Model filter patterns support the `*` wildcard only and are case-insensitive. Patterns match the entire model name (e.g., `ibm-granite/*` matches all models starting with \\"ibm-granite/\\").')],
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        filter_status: Annotated[StrictStr | None, Field(description="Filter the response to show specific model statuses: - `all` (default): Show all models regardless of inclusion status - `included`: Show only models that pass the configured filters - `excluded`: Show only models that are filtered out")] = None,
        catalog_data: Annotated[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes] | None, Field(description="Optional YAML file containing the catalog data (models).  This field enables stateless preview of new sources before saving them. When provided, the catalog data is read directly from this file instead of from the `yamlCatalogPath` property in the config.  **Two modes of operation:** 1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files. The models are read from `catalogData`, allowing preview    without saving anything to the server. 2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property pointing to a catalog file on the server filesystem.  If both `catalogData` and `yamlCatalogPath` are provided, `catalogData` takes precedence.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CatalogSourcePreviewResponse]:
        """Preview catalog source configuration

        Accepts a catalog source configuration and returns a list of models showing which would be included or excluded based on the configured filters. This allows users to test and validate their source configurations before applying them.  **Two modes of operation:**  1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files via multipart form. The models are read directly from    the uploaded `catalogData`, enabling preview of new sources before saving    anything to the server. This is ideal for testing configurations.  2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property. The models are read from the specified file path on the server.    Use this for previewing changes to existing saved sources.

        :param config: YAML file containing the catalog source configuration. The file should contain a source definition with type and properties fields, including optional includedModels and excludedModels filters.  Model filter patterns support the `*` wildcard only and are case-insensitive. Patterns match the entire model name (e.g., `ibm-granite/*` matches all models starting with \\\"ibm-granite/\\\"). (required)
        :type config: bytearray
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param filter_status: Filter the response to show specific model statuses: - `all` (default): Show all models regardless of inclusion status - `included`: Show only models that pass the configured filters - `excluded`: Show only models that are filtered out
        :type filter_status: str
        :param catalog_data: Optional YAML file containing the catalog data (models).  This field enables stateless preview of new sources before saving them. When provided, the catalog data is read directly from this file instead of from the `yamlCatalogPath` property in the config.  **Two modes of operation:** 1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files. The models are read from `catalogData`, allowing preview    without saving anything to the server. 2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property pointing to a catalog file on the server filesystem.  If both `catalogData` and `yamlCatalogPath` are provided, `catalogData` takes precedence.
        :type catalog_data: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._preview_catalog_source_serialize(
            config=config,
            page_size=page_size,
            next_page_token=next_page_token,
            filter_status=filter_status,
            catalog_data=catalog_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogSourcePreviewResponse",
            "400": "Error",
            "401": "Error",
            "422": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def preview_catalog_source_without_preload_content(
        self,
        config: Annotated[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes], Field(description='YAML file containing the catalog source configuration. The file should contain a source definition with type and properties fields, including optional includedModels and excludedModels filters.  Model filter patterns support the `*` wildcard only and are case-insensitive. Patterns match the entire model name (e.g., `ibm-granite/*` matches all models starting with \\"ibm-granite/\\").')],
        page_size: Annotated[StrictStr | None, Field(description="Number of entities in each page.")] = None,
        next_page_token: Annotated[StrictStr | None, Field(description="Token to use to retrieve next page of results.")] = None,
        filter_status: Annotated[StrictStr | None, Field(description="Filter the response to show specific model statuses: - `all` (default): Show all models regardless of inclusion status - `included`: Show only models that pass the configured filters - `excluded`: Show only models that are filtered out")] = None,
        catalog_data: Annotated[StrictBytes | StrictStr | tuple[StrictStr, StrictBytes] | None, Field(description="Optional YAML file containing the catalog data (models).  This field enables stateless preview of new sources before saving them. When provided, the catalog data is read directly from this file instead of from the `yamlCatalogPath` property in the config.  **Two modes of operation:** 1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files. The models are read from `catalogData`, allowing preview    without saving anything to the server. 2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property pointing to a catalog file on the server filesystem.  If both `catalogData` and `yamlCatalogPath` are provided, `catalogData` takes precedence.")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Preview catalog source configuration

        Accepts a catalog source configuration and returns a list of models showing which would be included or excluded based on the configured filters. This allows users to test and validate their source configurations before applying them.  **Two modes of operation:**  1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files via multipart form. The models are read directly from    the uploaded `catalogData`, enabling preview of new sources before saving    anything to the server. This is ideal for testing configurations.  2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property. The models are read from the specified file path on the server.    Use this for previewing changes to existing saved sources.

        :param config: YAML file containing the catalog source configuration. The file should contain a source definition with type and properties fields, including optional includedModels and excludedModels filters.  Model filter patterns support the `*` wildcard only and are case-insensitive. Patterns match the entire model name (e.g., `ibm-granite/*` matches all models starting with \\\"ibm-granite/\\\"). (required)
        :type config: bytearray
        :param page_size: Number of entities in each page.
        :type page_size: str
        :param next_page_token: Token to use to retrieve next page of results.
        :type next_page_token: str
        :param filter_status: Filter the response to show specific model statuses: - `all` (default): Show all models regardless of inclusion status - `included`: Show only models that pass the configured filters - `excluded`: Show only models that are filtered out
        :type filter_status: str
        :param catalog_data: Optional YAML file containing the catalog data (models).  This field enables stateless preview of new sources before saving them. When provided, the catalog data is read directly from this file instead of from the `yamlCatalogPath` property in the config.  **Two modes of operation:** 1. **Stateless mode (recommended for new sources):** Upload both `config` and    `catalogData` files. The models are read from `catalogData`, allowing preview    without saving anything to the server. 2. **Path mode (for existing sources):** Upload only `config` with a `yamlCatalogPath`    property pointing to a catalog file on the server filesystem.  If both `catalogData` and `yamlCatalogPath` are provided, `catalogData` takes precedence.
        :type catalog_data: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        _param = self._preview_catalog_source_serialize(
            config=config,
            page_size=page_size,
            next_page_token=next_page_token,
            filter_status=filter_status,
            catalog_data=catalog_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "CatalogSourcePreviewResponse",
            "400": "Error",
            "401": "Error",
            "422": "Error",
            "500": "Error",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _preview_catalog_source_serialize(
        self,
        config,
        page_size,
        next_page_token,
        filter_status,
        catalog_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if next_page_token is not None:

            _query_params.append(("nextPageToken", next_page_token))

        if filter_status is not None:

            _query_params.append(("filterStatus", filter_status))

        # process the header parameters
        # process the form parameters
        if config is not None:
            _files["config"] = config
        if catalog_data is not None:
            _files["catalogData"] = catalog_data
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        "multipart/form-data"
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: list[str] = [
            "Bearer"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/model_catalog/v1alpha1/sources/preview",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


