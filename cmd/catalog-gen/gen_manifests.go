package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// generateKustomizeBase generates kustomize base manifests.
func generateKustomizeBase(config CatalogConfig) error {
	entityName := config.Spec.Entity.Name
	lowerName := strings.ToLower(entityName)

	data := map[string]any{
		"Name":            config.Metadata.Name,
		"EntityName":      entityName,
		"EntityNameLower": lowerName,
	}

	baseDir := filepath.Join("manifests", "kustomize", "base")
	if err := ensureDir(baseDir); err != nil {
		return err
	}

	if err := executeTemplate(TmplManifestsDeployment, filepath.Join(baseDir, "deployment.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsService, filepath.Join(baseDir, "service.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsSources, filepath.Join(baseDir, "sources.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsSampleCatalog, filepath.Join(baseDir, "sample-catalog.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsKustomization, filepath.Join(baseDir, "kustomization.yaml"), data); err != nil {
		return err
	}

	return nil
}

// generateDevOverlay generates the dev kustomize overlay.
func generateDevOverlay(config CatalogConfig) error {
	entityName := config.Spec.Entity.Name
	lowerName := strings.ToLower(entityName)
	hasArtifacts := len(config.Spec.Artifacts) > 0

	// Build artifacts path line for sources.yaml
	artifactsPathLine := ""
	if hasArtifacts {
		artifactsPathLine = "      yamlArtifactsPath: artifacts.yaml"
	}

	// Build extra files for kustomization
	extraFiles := ""
	if hasArtifacts {
		extraFiles = "\n      - artifacts.yaml"
	}

	data := map[string]any{
		"Name":              config.Metadata.Name,
		"EntityName":        entityName,
		"EntityNameLower":   lowerName,
		"ArtifactsPathLine": artifactsPathLine,
		"ExtraFiles":        extraFiles,
	}

	devDir := filepath.Join("manifests", "kustomize", "overlays", "dev")
	if err := ensureDir(devDir); err != nil {
		return err
	}

	if err := executeTemplate(TmplManifestsDevSources, filepath.Join(devDir, "sources.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsDevSampleCatalog, filepath.Join(devDir, "sample-catalog.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsDevKustomization, filepath.Join(devDir, "kustomization.yaml"), data); err != nil {
		return err
	}

	// Generate sample artifacts file if artifacts are configured
	if hasArtifacts {
		if err := generateDevArtifactsFile(config, devDir); err != nil {
			return err
		}
	}

	return nil
}

// generateDevArtifactsFile generates a sample artifacts.yaml file for development.
func generateDevArtifactsFile(config CatalogConfig, devDir string) error {
	entityName := config.Spec.Entity.Name
	lowerName := strings.ToLower(entityName)

	var artifactsContent strings.Builder
	artifactsContent.WriteString(`# Code generated by catalog-gen. DO NOT EDIT.
# To regenerate: catalog-gen generate
#
# Development sample artifacts data
# Artifacts are linked to entities by ` + lowerName + `Name field.
`)

	// Generate sample artifacts for each artifact type
	for _, artifact := range config.Spec.Artifacts {
		lowerArtifactName := strings.ToLower(artifact.Name)
		artifactsContent.WriteString(fmt.Sprintf(`
# %s artifacts linked to %s entities
%ss:
  - %sName: example-%s-1
    name: sample-%s-1
`, artifact.Name, entityName, lowerArtifactName, lowerName, lowerName, lowerArtifactName))

		// Add sample property values
		for _, prop := range artifact.Properties {
			switch prop.Type {
			case "string":
				artifactsContent.WriteString(fmt.Sprintf("    %s: \"sample %s value\"\n", prop.Name, prop.Name))
			case "integer", "int", "int64":
				artifactsContent.WriteString(fmt.Sprintf("    %s: 42\n", prop.Name))
			case "boolean", "bool":
				artifactsContent.WriteString(fmt.Sprintf("    %s: true\n", prop.Name))
			}
		}

		// Add second sample artifact
		artifactsContent.WriteString(fmt.Sprintf(`  - %sName: example-%s-2
    name: sample-%s-2
`, lowerName, lowerName, lowerArtifactName))

		for _, prop := range artifact.Properties {
			switch prop.Type {
			case "string":
				artifactsContent.WriteString(fmt.Sprintf("    %s: \"another %s value\"\n", prop.Name, prop.Name))
			case "integer", "int", "int64":
				artifactsContent.WriteString(fmt.Sprintf("    %s: 100\n", prop.Name))
			case "boolean", "bool":
				artifactsContent.WriteString(fmt.Sprintf("    %s: false\n", prop.Name))
			}
		}
	}

	artifactsPath := filepath.Join(devDir, "artifacts.yaml")
	if err := os.WriteFile(artifactsPath, []byte(artifactsContent.String()), 0644); err != nil {
		return fmt.Errorf("failed to write artifacts.yaml: %w", err)
	}

	return nil
}

// generateSampleCatalog generates the sample catalog files.
func generateSampleCatalog(config CatalogConfig) error {
	entityName := config.Spec.Entity.Name
	lowerName := strings.ToLower(entityName)

	data := map[string]any{
		"Name":            config.Metadata.Name,
		"EntityName":      entityName,
		"EntityNameLower": lowerName,
	}

	manifestsDir := filepath.Join("manifests", "kustomize", "base")
	if err := ensureDir(manifestsDir); err != nil {
		return err
	}

	if err := executeTemplate(TmplManifestsSampleCatalog, filepath.Join(manifestsDir, "sample-catalog.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsSources, filepath.Join(manifestsDir, "sources.yaml"), data); err != nil {
		return err
	}
	if err := executeTemplate(TmplManifestsKustomization, filepath.Join(manifestsDir, "kustomization.yaml"), data); err != nil {
		return err
	}

	return nil
}

// generateMakefile generates the Makefile.
func generateMakefile(config CatalogConfig) error {
	data := map[string]any{
		"Name":            config.Metadata.Name,
		"EntityNameLower": strings.ToLower(config.Spec.Entity.Name),
		"Port":            config.Spec.API.Port,
	}

	return executeTemplate(TmplMiscMakefile, "Makefile", data)
}

// generateREADME generates the README.md.
func generateREADME(config CatalogConfig) error {
	entityName := config.Spec.Entity.Name
	lowerName := strings.ToLower(entityName)

	data := map[string]any{
		"Name":            config.Metadata.Name,
		"EntityName":      entityName,
		"EntityNameLower": lowerName,
		"Package":         config.Spec.Package,
		"BasePath":        config.Spec.API.BasePath,
		"Port":            config.Spec.API.Port,
	}

	return executeTemplate(TmplMiscReadme, "README.md", data)
}

// generateGitignore generates the .gitignore file.
func generateGitignore() error {
	return executeTemplate(TmplMiscGitignore, ".gitignore", nil)
}

// generateOpenAPIGeneratorIgnore generates the .openapi-generator-ignore file.
func generateOpenAPIGeneratorIgnore() error {
	return executeTemplate(TmplMiscOpenAPIGeneratorIgnore, ".openapi-generator-ignore", nil)
}
