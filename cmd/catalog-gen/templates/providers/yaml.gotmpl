package providers

import (
	"context"
	"os"
	"path/filepath"

	"fmt"

	"github.com/golang/glog"
	k8syaml "k8s.io/apimachinery/pkg/util/yaml"
{{if .HasArtifacts}}
	"{{.Package}}/internal/catalog"
{{end}}	"{{.Package}}/internal/db/models"
	sharedmodels "github.com/kubeflow/model-registry/internal/db/models"
	pkgcatalog "github.com/kubeflow/model-registry/pkg/catalog"
	yamlprovider "github.com/kubeflow/model-registry/pkg/catalog/providers/yaml"
)

// yaml{{.EntityName}} represents a {{.EntityName}} entry in the YAML catalog file.
type yaml{{.EntityName}} struct {
	Name             string         `json:"name" yaml:"name"`
	ExternalId       string         `json:"externalId,omitempty" yaml:"externalId,omitempty"`
	Description      *string        `json:"description,omitempty" yaml:"description,omitempty"`
	CustomProperties map[string]any `json:"customProperties,omitempty" yaml:"customProperties,omitempty"`
{{.EntityPropertyFields}}}

// yaml{{.EntityName}}Catalog is the structure of the YAML catalog file.
type yaml{{.EntityName}}Catalog struct {
	{{.EntityName}}s []yaml{{.EntityName}} `json:"{{.EntityNameLower}}s" yaml:"{{.EntityNameLower}}s"`
}
{{.ArtifactStructs}}
// glogLogger implements yaml.Logger using glog.
type glogLogger struct{}

func (glogLogger) Infof(format string, args ...any)  { glog.Infof(format, args...) }
func (glogLogger) Errorf(format string, args ...any) { glog.Errorf(format, args...) }

// New{{.EntityName}}YAMLProvider creates a new YAML provider for {{.EntityName}} entities.
// It uses the reusable yaml.NewProviderFunc which includes automatic hot-reload
// via file watching (polling every 5 seconds for file changes).
func New{{.EntityName}}YAMLProvider() pkgcatalog.ProviderFunc[models.{{.EntityName}}, {{.ArtifactType}}] {
	return func(ctx context.Context, source *pkgcatalog.Source, reldir string) (<-chan pkgcatalog.Record[models.{{.EntityName}}, {{.ArtifactType}}], error) {
		// Resolve artifacts path from source properties (captured in parse closure)
		var artifactsPath string
		if ap, ok := source.Properties["yamlArtifactsPath"].(string); ok && ap != "" {
			if !filepath.IsAbs(ap) {
				ap = filepath.Join(reldir, ap)
			}
			artifactsPath = ap
		}

		config := yamlprovider.Config[models.{{.EntityName}}, {{.ArtifactType}}]{
			Parse: func(data []byte) ([]pkgcatalog.Record[models.{{.EntityName}}, {{.ArtifactType}}], error) {
				var artifactsData []byte
				if artifactsPath != "" {
					var err error
					artifactsData, err = os.ReadFile(artifactsPath)
					if err != nil {
						glog.Warningf("failed to read artifacts file %s: %v", artifactsPath, err)
					}
				}
				return parse{{.EntityName}}Catalog(data, artifactsData)
			},
			Logger: glogLogger{},
		}

		provider, err := yamlprovider.NewProvider(config, source, reldir)
		if err != nil {
			return nil, err
		}
		return provider.Records(ctx)
	}
}

// parse{{.EntityName}}Catalog parses the YAML catalog files into records.
func parse{{.EntityName}}Catalog(catalogData, artifactsData []byte) ([]pkgcatalog.Record[models.{{.EntityName}}, {{.ArtifactType}}], error) {
	var entityCatalog yaml{{.EntityName}}Catalog
	if err := k8syaml.UnmarshalStrict(catalogData, &entityCatalog); err != nil {
		return nil, err
	}
{{.ArtifactParseCode}}
	records := make([]pkgcatalog.Record[models.{{.EntityName}}, {{.ArtifactType}}], 0, len(entityCatalog.{{.EntityName}}s))
	for _, item := range entityCatalog.{{.EntityName}}s {
		name := item.Name
		var externalID *string
		if item.ExternalId != "" {
			externalID = &item.ExternalId
		}
		entity := models.New{{.EntityName}}(&models.{{.EntityName}}Attributes{
			Name:       &name,
			ExternalID: externalID,
		})
{{.EntityPropertyAssignments}}
		// Set base properties (description)
		var props []sharedmodels.Properties
		if item.Description != nil {
			props = append(props, sharedmodels.NewStringProperty("description", *item.Description, false))
		}
		if len(props) > 0 {
			entity.(*models.{{.EntityName}}Impl).Properties = &props
		}

		// Set custom properties
		if len(item.CustomProperties) > 0 {
			var customProps []sharedmodels.Properties
			for k, v := range item.CustomProperties {
				switch val := v.(type) {
				case string:
					customProps = append(customProps, sharedmodels.NewStringProperty(k, val, true))
				case float64:
					customProps = append(customProps, sharedmodels.NewDoubleProperty(k, val, true))
				case bool:
					customProps = append(customProps, sharedmodels.NewBoolProperty(k, val, true))
				default:
					customProps = append(customProps, sharedmodels.NewStringProperty(k, fmt.Sprintf("%v", val), true))
				}
			}
			entity.(*models.{{.EntityName}}Impl).CustomProperties = &customProps
		}

		record := pkgcatalog.Record[models.{{.EntityName}}, {{.ArtifactType}}]{Entity: entity}
{{.ArtifactMatchCode}}
		records = append(records, record)
	}

	return records, nil
}
