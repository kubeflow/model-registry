// Code generated by catalog-gen. DO NOT EDIT.
// To regenerate: catalog-gen generate
// Source: catalog.yaml
//
// Package {{.PackageName}} provides the {{.EntityName}} catalog plugin for the unified catalog server.
package {{.PackageName}}

import (
	"context"
	"flag"
	"fmt"
	"log/slog"
	"path/filepath"
	"reflect"
	"sync/atomic"

	"github.com/go-chi/chi/v5"
	"gorm.io/gorm"

	"{{.Package}}/internal/catalog"
	"{{.Package}}/internal/catalog/providers"
	"{{.Package}}/internal/db/models"
	"{{.Package}}/internal/db/service"
	"{{.Package}}/internal/server/openapi"
	"github.com/kubeflow/model-registry/internal/datastore"
	"github.com/kubeflow/model-registry/internal/datastore/embedmd"
	pkgcatalog "github.com/kubeflow/model-registry/pkg/catalog"
	"github.com/kubeflow/model-registry/pkg/catalog/plugin"
)

const (
	// PluginName is the identifier for this plugin.
	PluginName = "{{.Name}}"

	// PluginVersion is the API version.
	PluginVersion = "v1alpha1"
)

// {{.EntityName}}CatalogPlugin implements the CatalogPlugin interface for {{.EntityName}} catalogs.
type {{.EntityName}}CatalogPlugin struct {
	cfg      plugin.Config
	logger   *slog.Logger
	loaders  []plugin.CatalogLoader
	services service.Services
	healthy  atomic.Bool
	started  atomic.Bool
}

// Name returns the plugin name.
func (p *{{.EntityName}}CatalogPlugin) Name() string {
	return PluginName
}

// Version returns the plugin API version.
func (p *{{.EntityName}}CatalogPlugin) Version() string {
	return PluginVersion
}

// Description returns a human-readable description.
func (p *{{.EntityName}}CatalogPlugin) Description() string {
	return "{{.EntityName}} catalog"
}

// BasePath returns the API base path for this plugin.
func (p *{{.EntityName}}CatalogPlugin) BasePath() string {
	return "{{.BasePath}}"
}

// RegisterFlags registers custom CLI flags for this plugin.
// Add your plugin-specific flags here. They will be available after flag.Parse().
func (p *{{.EntityName}}CatalogPlugin) RegisterFlags(fs *flag.FlagSet) {
	// Register plugin-specific CLI flags here. Example:
	// fs.StringVar(&p.myFlag, "{{.Name}}-my-flag", "default", "Description")
}

// Init initializes the plugin with configuration.
func (p *{{.EntityName}}CatalogPlugin) Init(ctx context.Context, cfg plugin.Config) error {
	p.cfg = cfg
	p.logger = cfg.Logger
	if p.logger == nil {
		p.logger = slog.Default()
	}

	p.logger.Info("initializing {{.Name}} plugin")

	// Build config paths from source properties or origins
	paths := make([]string, 0)
	pathsSet := make(map[string]bool)
	for _, src := range cfg.Section.Sources {
		// Check for loaderConfigPath property first (allows separate loader config)
		if loaderPath, ok := src.Properties["loaderConfigPath"].(string); ok && loaderPath != "" {
			// Resolve relative to source origin directory
			if !filepath.IsAbs(loaderPath) && src.Origin != "" {
				loaderPath = filepath.Join(filepath.Dir(src.Origin), loaderPath)
			}
			if !pathsSet[loaderPath] {
				paths = append(paths, loaderPath)
				pathsSet[loaderPath] = true
			}
		} else if src.Origin != "" && !pathsSet[src.Origin] {
			paths = append(paths, src.Origin)
			pathsSet[src.Origin] = true
		}
	}
	if len(paths) == 0 {
		paths = cfg.ConfigPaths
	}

	// Convert to absolute paths
	absPaths := make([]string, 0, len(paths))
	for _, path := range paths {
		if absPath, err := filepath.Abs(path); err == nil {
			absPaths = append(absPaths, absPath)
		} else {
			absPaths = append(absPaths, path)
		}
	}

	// Initialize services from the database connection
	services, err := p.initServices(cfg.DB)
	if err != nil {
		return fmt.Errorf("failed to initialize services: %w", err)
	}
	p.services = services

	// Set up provider registry
	registry := pkgcatalog.NewProviderRegistry[models.{{.EntityName}}, {{.ArtifactType}}]()
	if err := registry.Register("yaml", providers.New{{.EntityName}}YAMLProvider()); err != nil {
		return fmt.Errorf("failed to register YAML provider: %w", err)
	}

	// Create the core loader and add it to the loaders list.
	// Additional custom loaders can be appended here.
	p.loaders = append(p.loaders, catalog.NewLoader(services, absPaths, registry))

	p.logger.Info("{{.Name}} plugin initialized", "paths", absPaths)
	return nil
}

// initServices creates the service layer from the database connection.
func (p *{{.EntityName}}CatalogPlugin) initServices(db *gorm.DB) (service.Services, error) {
	spec := service.DatastoreSpec()

	connector, err := datastore.NewConnector("embedmd", &embedmd.EmbedMDConfig{DB: db, SkipMigrations: true})
	if err != nil {
		return service.Services{}, fmt.Errorf("failed to create connector: %w", err)
	}

	repoSet, err := connector.Connect(spec)
	if err != nil {
		return service.Services{}, fmt.Errorf("failed to connect: %w", err)
	}

	repo, err := getRepository[models.{{.EntityName}}Repository](repoSet)
	if err != nil {
		return service.Services{}, fmt.Errorf("failed to get {{.EntityName}} repository: %w", err)
	}

	return service.NewServices(repo), nil
}

// Start begins background operations (hot-reload, watchers).
func (p *{{.EntityName}}CatalogPlugin) Start(ctx context.Context) error {
	p.logger.Info("starting {{.Name}} plugin")

	for _, loader := range p.loaders {
		if err := loader.Start(ctx); err != nil {
			return fmt.Errorf("failed to start loader: %w", err)
		}
	}

	p.started.Store(true)
	p.healthy.Store(true)

	p.logger.Info("{{.Name}} plugin started")
	return nil
}

// Stop gracefully shuts down the plugin.
func (p *{{.EntityName}}CatalogPlugin) Stop(ctx context.Context) error {
	p.logger.Info("stopping {{.Name}} plugin")

	for i := len(p.loaders) - 1; i >= 0; i-- {
		if err := p.loaders[i].Stop(ctx); err != nil {
			p.logger.Error("loader stop failed", "error", err)
		}
	}

	p.started.Store(false)
	p.healthy.Store(false)
	return nil
}

// Healthy returns true if the plugin is functioning correctly.
func (p *{{.EntityName}}CatalogPlugin) Healthy() bool {
	return p.healthy.Load()
}

// RegisterRoutes mounts the plugin's HTTP routes on the provided router.
func (p *{{.EntityName}}CatalogPlugin) RegisterRoutes(router chi.Router) error {
	p.logger.Info("registering {{.Name}} routes")

	// Create the OpenAPI service
	apiService := openapi.New{{.EntityName}}CatalogServiceAPIService(p.services)
	apiController := openapi.NewDefaultAPIController(apiService)

	// Mount routes - remove the base path prefix since chi.Router already handles that
	basePath := "{{.BasePath}}"
	for _, route := range apiController.OrderedRoutes() {
		pattern := route.Pattern
		if len(pattern) > len(basePath) && pattern[:len(basePath)] == basePath {
			pattern = pattern[len(basePath):]
		}
		if pattern == "" {
			pattern = "/"
		}
		router.Method(route.Method, pattern, route.HandlerFunc)
		p.logger.Debug("registered route", "method", route.Method, "pattern", pattern)
	}

	return nil
}

// Migrations returns database migrations for this plugin.
func (p *{{.EntityName}}CatalogPlugin) Migrations() []plugin.Migration {
	// Migrations are handled by the datastore layer
	return nil
}

// getRepository extracts a repository of type T from the RepoSet.
func getRepository[T any](rs datastore.RepoSet) (T, error) {
	var zero T
	t := reflect.TypeFor[T]()

	repo, err := rs.Repository(t)
	if err != nil {
		return zero, err
	}

	result, ok := repo.(T)
	if !ok {
		return zero, fmt.Errorf("repository type mismatch: expected %T, got %T", zero, repo)
	}

	return result, nil
}
