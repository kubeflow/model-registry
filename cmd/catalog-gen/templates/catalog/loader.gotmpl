// Code generated by catalog-gen. DO NOT EDIT.
// To regenerate: catalog-gen generate
// Source: catalog.yaml

package catalog

import (
	"context"
{{if .HasArtifacts}}	"fmt"
{{end}}
	"github.com/kubeflow/model-registry/pkg/catalog"
	sharedmodels "github.com/kubeflow/model-registry/internal/db/models"
	"{{.Package}}/internal/db/models"
	"{{.Package}}/internal/db/service"
)
{{if .HasArtifacts}}
// Artifact is a union interface for all artifact types in this catalog.
type Artifact interface {
	GetID() *int32
}
{{end}}
// Loader wraps the generic catalog loader with {{.EntityName}}-specific types.
type Loader struct {
	*catalog.Loader[models.{{.EntityName}}, {{.ArtifactType}}]
	services service.Services
}

// NewLoader creates a new catalog loader.
func NewLoader(services service.Services, paths []string, registry *catalog.ProviderRegistry[models.{{.EntityName}}, {{.ArtifactType}}]) *Loader {
	cfg := catalog.LoaderConfig[models.{{.EntityName}}, {{.ArtifactType}}]{
		Paths:            paths,
		ProviderRegistry: registry,
		SaveEntity: func(entity models.{{.EntityName}}) (models.{{.EntityName}}, error) {
			return services.{{.EntityName}}Repository.Save(entity)
		},
		SaveArtifact: saveArtifact(services),
		GetEntityID: func(entity models.{{.EntityName}}) *int32 {
			return entity.GetID()
		},
		GetEntityName: func(entity models.{{.EntityName}}) string {
			if attrs := entity.GetAttributes(); attrs != nil && attrs.Name != nil {
				return *attrs.Name
			}
			return ""
		},
		DeleteArtifactsByEntity: deleteArtifactsByEntity(services),
		DeleteEntitiesBySource: func(sourceID string) error {
			return services.{{.EntityName}}Repository.DeleteBySource(sourceID)
		},
		GetDistinctSourceIDs: func() ([]string, error) {
			return services.{{.EntityName}}Repository.GetDistinctSourceIDs()
		},
		SetEntitySourceID: func(entity models.{{.EntityName}}, sourceID string) {
			setEntitySourceID(entity, sourceID)
		},
		IsEntityNil: func(entity models.{{.EntityName}}) bool {
			return entity == nil
		},
	}

	return &Loader{
		Loader:   catalog.NewLoader(cfg),
		services: services,
	}
}

// saveArtifact returns a function that saves an artifact to the appropriate repository.
func saveArtifact(services service.Services) func(artifact {{.ArtifactType}}, entityID int32) error {
	return func(artifact {{.ArtifactType}}, entityID int32) error {
{{if .HasArtifacts}}		switch a := artifact.(type) {
{{.ArtifactSaveCases}}		default:
			return fmt.Errorf("unknown artifact type: %T", artifact)
		}
{{else}}		// No artifacts configured
		return nil
{{end}}	}
}

// deleteArtifactsByEntity returns a function that deletes all artifacts for an entity.
func deleteArtifactsByEntity(services service.Services) func(entityID int32) error {
	return func(entityID int32) error {
{{.ArtifactDeleteCalls}}		return nil
	}
}

// Start begins loading catalog data.
func (l *Loader) Start(ctx context.Context) error {
	return l.Loader.Start(ctx)
}

// setEntitySourceID sets the source_id as a property on the entity.
// This follows the MLMD pattern where source_id is stored as a ContextProperty.
func setEntitySourceID(entity models.{{.EntityName}}, sourceID string) {
	props := entity.GetProperties()
	if props == nil {
		newProps := []sharedmodels.Properties{}
		props = &newProps
	}

	// Check if source_id already exists
	for i := range *props {
		if (*props)[i].Name == "source_id" {
			(*props)[i].StringValue = &sourceID
			return
		}
	}

	// Add new source_id property
	*props = append(*props, sharedmodels.Properties{
		Name:        "source_id",
		StringValue: &sourceID,
	})
}
