// Code generated by catalog-gen. DO NOT EDIT.
// To regenerate: catalog-gen generate
// Source: catalog.yaml

package service

import (
	"errors"
	"fmt"

	"gorm.io/gorm"

	"{{.Package}}/internal/db/models"
	"github.com/kubeflow/model-registry/internal/db/schema"
	sharedmodels "github.com/kubeflow/model-registry/internal/db/models"
	"github.com/kubeflow/model-registry/internal/db/service"
	"github.com/kubeflow/model-registry/internal/db/utils"
	"github.com/kubeflow/model-registry/internal/apiutils"
)

var Err{{.EntityName}}{{.ArtifactName}}ArtifactNotFound = errors.New("{{.LowerEntityName}} {{.LowerArtifactName}} artifact not found")

// {{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl uses the shared GenericRepository for MLMD-based storage.
type {{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl struct {
	*service.GenericRepository[models.{{.EntityName}}{{.ArtifactName}}Artifact, schema.Artifact, schema.ArtifactProperty, *models.{{.EntityName}}{{.ArtifactName}}ArtifactListOptions]
}

// New{{.EntityName}}{{.ArtifactName}}ArtifactRepository creates a new {{.ArtifactName}} artifact repository.
func New{{.EntityName}}{{.ArtifactName}}ArtifactRepository(db *gorm.DB, typeID int32) models.{{.EntityName}}{{.ArtifactName}}ArtifactRepository {
	r := &{{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl{}

	r.GenericRepository = service.NewGenericRepository(service.GenericRepositoryConfig[
		models.{{.EntityName}}{{.ArtifactName}}Artifact,
		schema.Artifact,
		schema.ArtifactProperty,
		*models.{{.EntityName}}{{.ArtifactName}}ArtifactListOptions,
	]{
		DB:                      db,
		TypeID:                  typeID,
		EntityToSchema:          map{{.EntityName}}{{.ArtifactName}}ArtifactToSchema,
		SchemaToEntity:          mapSchemaTo{{.EntityName}}{{.ArtifactName}}Artifact,
		EntityToProperties:      map{{.EntityName}}{{.ArtifactName}}ArtifactToProperties,
		NotFoundError:           Err{{.EntityName}}{{.ArtifactName}}ArtifactNotFound,
		EntityName:              "{{.LowerEntityName}} {{.LowerArtifactName}} artifact",
		PropertyFieldName:       "artifact_id",
		ApplyListFilters:        apply{{.EntityName}}{{.ArtifactName}}ArtifactListFilters,
		IsNewEntity:             func(entity models.{{.EntityName}}{{.ArtifactName}}Artifact) bool { return entity.GetID() == nil },
		HasCustomProperties:     func(entity models.{{.EntityName}}{{.ArtifactName}}Artifact) bool { return entity.GetCustomProperties() != nil },
		PreserveHistoricalTimes: true,
	})

	return r
}

func (r *{{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl) Save(artifact models.{{.EntityName}}{{.ArtifactName}}Artifact, parentResourceID *int32) (models.{{.EntityName}}{{.ArtifactName}}Artifact, error) {
	config := r.GetConfig()
	if artifact.GetTypeID() == nil {
		if config.TypeID > 0 {
			artifact.SetTypeID(config.TypeID)
		}
	}

	attr := artifact.GetAttributes()
	if artifact.GetID() == nil && attr != nil && attr.Name != nil {
		existing, err := r.lookupByName(*attr.Name)
		if err != nil {
			if !errors.Is(err, Err{{.EntityName}}{{.ArtifactName}}ArtifactNotFound) {
				return nil, fmt.Errorf("error finding existing artifact named %s: %w", *attr.Name, err)
			}
		} else {
			artifact.SetID(existing.ID)
		}
	}

	return r.GenericRepository.Save(artifact, parentResourceID)
}

func (r *{{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl) List(listOptions models.{{.EntityName}}{{.ArtifactName}}ArtifactListOptions) (*sharedmodels.ListWrapper[models.{{.EntityName}}{{.ArtifactName}}Artifact], error) {
	return r.GenericRepository.List(&listOptions)
}

func (r *{{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl) DeleteByParentID(parentID int32) error {
	config := r.GetConfig()

	// Find all artifact IDs linked to this parent via Attribution
	var artifactIDs []int32
	err := config.DB.Model(&schema.Attribution{}).
		Select("artifact_id").
		Where("context_id = ?", parentID).
		Joins("JOIN "+utils.GetTableName(config.DB, &schema.Artifact{})+" ON "+utils.GetColumnRef(config.DB, &schema.Artifact{}, "id")+" = "+utils.GetColumnRef(config.DB, &schema.Attribution{}, "artifact_id")).
		Where(utils.GetColumnRef(config.DB, &schema.Artifact{}, "type_id")+" = ?", config.TypeID).
		Pluck("artifact_id", &artifactIDs).Error
	if err != nil {
		return fmt.Errorf("failed to find artifacts for parent %d: %w", parentID, err)
	}

	if len(artifactIDs) == 0 {
		return nil
	}

	// Delete properties
	if err := config.DB.Where("artifact_id IN ?", artifactIDs).Delete(&schema.ArtifactProperty{}).Error; err != nil {
		return fmt.Errorf("failed to delete artifact properties: %w", err)
	}

	// Delete attributions
	if err := config.DB.Where("artifact_id IN ?", artifactIDs).Delete(&schema.Attribution{}).Error; err != nil {
		return fmt.Errorf("failed to delete attributions: %w", err)
	}

	// Delete artifacts
	if err := config.DB.Where("id IN ?", artifactIDs).Delete(&schema.Artifact{}).Error; err != nil {
		return fmt.Errorf("failed to delete artifacts: %w", err)
	}

	return nil
}

func (r *{{.EntityName}}{{.ArtifactName}}ArtifactRepositoryImpl) lookupByName(name string) (*schema.Artifact, error) {
	var entity schema.Artifact
	config := r.GetConfig()

	if err := config.DB.Where("name = ? AND type_id = ?", name, config.TypeID).First(&entity).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("%w: %v", config.NotFoundError, err)
		}
		return nil, fmt.Errorf("error getting %s by name: %w", config.EntityName, err)
	}

	return &entity, nil
}

func apply{{.EntityName}}{{.ArtifactName}}ArtifactListFilters(query *gorm.DB, listOptions *models.{{.EntityName}}{{.ArtifactName}}ArtifactListOptions) *gorm.DB {
	if listOptions.Name != nil {
		query = query.Where("name LIKE ?", fmt.Sprintf("%%:%s", *listOptions.Name))
	} else if listOptions.ExternalID != nil {
		query = query.Where("external_id = ?", listOptions.ExternalID)
	}

	if listOptions.ParentResourceID != nil {
		query = query.Joins(utils.BuildAttributionJoin(query)).
			Where(utils.GetColumnRef(query, &schema.Attribution{}, "context_id")+" = ?", listOptions.ParentResourceID)
	}

	return query
}

func map{{.EntityName}}{{.ArtifactName}}ArtifactToSchema(artifact models.{{.EntityName}}{{.ArtifactName}}Artifact) schema.Artifact {
	if artifact == nil {
		return schema.Artifact{}
	}

	schemaArtifact := schema.Artifact{
		ID:     apiutils.ZeroIfNil(artifact.GetID()),
		TypeID: apiutils.ZeroIfNil(artifact.GetTypeID()),
	}

	if artifact.GetAttributes() != nil {
		schemaArtifact.Name = artifact.GetAttributes().Name
		schemaArtifact.ExternalID = artifact.GetAttributes().ExternalID
		schemaArtifact.CreateTimeSinceEpoch = apiutils.ZeroIfNil(artifact.GetAttributes().CreateTimeSinceEpoch)
		schemaArtifact.LastUpdateTimeSinceEpoch = apiutils.ZeroIfNil(artifact.GetAttributes().LastUpdateTimeSinceEpoch)
	}

	return schemaArtifact
}

func map{{.EntityName}}{{.ArtifactName}}ArtifactToProperties(artifact models.{{.EntityName}}{{.ArtifactName}}Artifact, artifactID int32) []schema.ArtifactProperty {
	if artifact == nil {
		return []schema.ArtifactProperty{}
	}

	properties := []schema.ArtifactProperty{}

	// Map custom properties from attributes
	if artifact.GetAttributes() != nil {
		attr := artifact.GetAttributes()
{{.PropWriteStatements}}
	}

	if artifact.GetCustomProperties() != nil {
		for _, prop := range *artifact.GetCustomProperties() {
			properties = append(properties, service.MapPropertiesToArtifactProperty(prop, artifactID, true))
		}
	}

	return properties
}

func mapSchemaTo{{.EntityName}}{{.ArtifactName}}Artifact(artifact schema.Artifact, artProperties []schema.ArtifactProperty) models.{{.EntityName}}{{.ArtifactName}}Artifact {
{{.PropVarDecls}}

	for _, p := range artProperties {
		if !p.IsCustomProperty {
			switch p.Name {
{{.PropReadCases}}
			}
		}
	}

	result := models.{{.EntityName}}{{.ArtifactName}}ArtifactImpl{
		ID:     &artifact.ID,
		TypeID: &artifact.TypeID,
		Attributes: &models.{{.EntityName}}{{.ArtifactName}}ArtifactAttributes{
			Name:                     artifact.Name,
			ExternalID:               artifact.ExternalID,
			CreateTimeSinceEpoch:     &artifact.CreateTimeSinceEpoch,
			LastUpdateTimeSinceEpoch: &artifact.LastUpdateTimeSinceEpoch,
{{.PropAttrAssignments}}
		},
	}

	customProperties := []sharedmodels.Properties{}
	for _, prop := range artProperties {
		if prop.IsCustomProperty {
			customProperties = append(customProperties, service.MapArtifactPropertyToProperties(prop))
		}
	}
	result.CustomProperties = &customProperties

	return &result
}
