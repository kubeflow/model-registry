/*
Model Registry REST API

REST API for Model Registry to create and manage ML model metadata

API version: v1alpha1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// ArtifactState  - PENDING: A state indicating that the artifact may exist.  - LIVE: A state indicating that the artifact should exist, unless something external to the system deletes it.  - MARKED_FOR_DELETION: A state indicating that the artifact should be deleted.  - DELETED: A state indicating that the artifact has been deleted.  - ABANDONED: A state indicating that the artifact has been abandoned, which may be due to a failed or cancelled execution.  - REFERENCE: A state indicating that the artifact is a reference artifact. At execution start time, the orchestrator produces an output artifact for each output key with state PENDING. However, for an intermediate artifact, this first artifact's state will be REFERENCE. Intermediate artifacts emitted during a component's execution will copy the REFERENCE artifact's attributes. At the end of an execution, the artifact state should remain REFERENCE instead of being changed to LIVE.  See also: ml-metadata Artifact.State
type ArtifactState string

// List of ArtifactState
const (
	ARTIFACTSTATE_UNKNOWN             ArtifactState = "UNKNOWN"
	ARTIFACTSTATE_PENDING             ArtifactState = "PENDING"
	ARTIFACTSTATE_LIVE                ArtifactState = "LIVE"
	ARTIFACTSTATE_MARKED_FOR_DELETION ArtifactState = "MARKED_FOR_DELETION"
	ARTIFACTSTATE_DELETED             ArtifactState = "DELETED"
	ARTIFACTSTATE_ABANDONED           ArtifactState = "ABANDONED"
	ARTIFACTSTATE_REFERENCE           ArtifactState = "REFERENCE"
)

// All allowed values of ArtifactState enum
var AllowedArtifactStateEnumValues = []ArtifactState{
	"UNKNOWN",
	"PENDING",
	"LIVE",
	"MARKED_FOR_DELETION",
	"DELETED",
	"ABANDONED",
	"REFERENCE",
}

func (v *ArtifactState) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ArtifactState(value)
	for _, existing := range AllowedArtifactStateEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ArtifactState", value)
}

// NewArtifactStateFromValue returns a pointer to a valid ArtifactState
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewArtifactStateFromValue(v string) (*ArtifactState, error) {
	ev := ArtifactState(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ArtifactState: valid values are %v", v, AllowedArtifactStateEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ArtifactState) IsValid() bool {
	for _, existing := range AllowedArtifactStateEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ArtifactState value
func (v ArtifactState) Ptr() *ArtifactState {
	return &v
}

type NullableArtifactState struct {
	value *ArtifactState
	isSet bool
}

func (v NullableArtifactState) Get() *ArtifactState {
	return v.value
}

func (v *NullableArtifactState) Set(val *ArtifactState) {
	v.value = val
	v.isSet = true
}

func (v NullableArtifactState) IsSet() bool {
	return v.isSet
}

func (v *NullableArtifactState) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableArtifactState(val *ArtifactState) *NullableArtifactState {
	return &NullableArtifactState{value: val, isSet: true}
}

func (v NullableArtifactState) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableArtifactState) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
